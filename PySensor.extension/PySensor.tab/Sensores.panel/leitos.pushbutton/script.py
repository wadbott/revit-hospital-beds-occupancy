"""PyRevit Extension program that integrates a BIM model and environmental 
sensors in order to optimize hospital beds occupancy.

	__author__ = Wadham Bottacin -- https://github.com/wadbott

"""

# coding=utf-8

__title__ = 'Leitos'
__author__ = 'Wadham Bottacin -- https://github.com/wadbott'

import clr
clr.AddReference('System.Windows.Forms')
clr.AddReference('IronPython.Wpf')
from pyfirmata import Arduino, util
import json
import wpf
from System import Windows
import os

from Autodesk.Revit.DB import *
from pyrevit import script  
from pyrevit import forms

def initial_loading():
	"""First thing to happen, here we defines global variables, revit active 
	document, XAML file, data fallback and start our Arduino UNO board. Also,
	a search for all hospital beds is done and it is appended to a list.

	"""
	print("Loading variables...")
	global pins, beds, doc, xamlfile, datafallback, board, iterator, get_pin

	get_pin = {}

	pins = [
		'd:2:i', 'd:3:i', 'd:4:i', 'd:5:i', 'd:6:i', 'd:7:i', \
		'd:8:i', 'd:9:i','d:10:i'
	]

	beds =  []

	# Active Revit Document
	doc = __revit__.ActiveUIDocument.Document

	# XAML file Path
	xamlfile = script.get_bundle_file('ui.xaml')

	# Data access and fallback path (images and JSON files)
	datafallback = ('C:\\Users\\Usuario\\AppData\\Roaming\\pyRevit\\'
					'Extensions\\PySensor.extension\\PySensor.tab\\'
					'Sensores.panel\\leitos.pushbutton')

	# Open the Arduino Door 'COM3' and get PIN data. 'a' stands for 
	#analogic and 'd' for digital signal
	board = Arduino('COM3')

	iterator = util.Iterator(board)
	iterator.start()	

	# Search for ALL hospital beds in the model and append it to beds array	
	beds_collector = FilteredElementCollector(doc)\
					.OfCategory(BuiltInCategory.OST_SpecialityEquipment)\
					.WhereElementIsNotElementType()

	for bed in beds_collector:
	    beds.append(bed.Id.IntegerValue)
	print("Variables loaded.")	

def refresh_sensor_reader():	
	""" This function will look for saved sensors its respective PIN. If later
	on we decide to add more sensor this function will look for new sensors and 
	open its PIN too. Also, the function add sensors name to sensors array and 
	it is used to create a list inside UI.
	"""
	print("Loading sensor list...")
	global sensors		

	sensors = []
	connected_pin = {}	

	with open(datafallback + '\\new_sensor_list.json', "r")\
					 as sensors_read_file:
	   	data = json.load(sensors_read_file)
	   	sensors_read_file.close()   	

		for sensor_name in data:
		    sensors.append(sensor_name)
		    #It will try to get_pin, if it is already connected it adds it to
		    #another array.
		    try:
				get_pin[sensor_name] = board.get_pin(data[sensor_name])	    	

		    except:
				print("Pin " + data[sensor_name] + " connected.")
				connected_pin[sensor_name] = get_pin[sensor_name]
				continue

	print("Sensor list loaded and PINs connected.")	
	return connected_pin

class MyWindow(Windows.Window):
	""" The base window call with all buttons defines and XAML from xamlfile.
	The background image is generated by export_img() function.
	Sensors - Name of each sensor added.
	Beds - Hospital bed ID
	Pins - List of all digital PINs of an Arduino UNO.
	"""
	def __init__(self):
		wpf.LoadComponent(self, xamlfile)        
		self.backgroundimage.Source = forms.utils\
					.bitmap_from_file(datafallback +  '\\level_1.png')
		self.combobox_sensors.ItemsSource = sensors
		self.combobox_beds.ItemsSource = beds
		self.combobox_pin.ItemsSource = pins
	def sensor_button(self, sender, args):        
		sensor_reader(self)
	def add_new_button(self, sender, args):
		add_new(self)
	def delete_button(self, sender, args):
		delete_sensor(self)
	def export_button(self, sender, args):        
		export_img(self)
	def close_button(self, sender, args):
		# Closes Arduino port.The connection with the a board can get messed 
		# up when a script is closed without calling board.exit() 
		#(which closes the serial connection) 

		board.exit()
		print("Port COM closed.")          
	def attach_button(self, sender, args):        
		attach_sensors(self)
	def detach_button(self, sender, args):        
		detach_sensor(self)
	def beds_button(self, sender, args):
		beds_occupied(self) 


def add_new(self):
	""" Get Text, written inside UI textbox, and Pin number. It pass the
	information to new_sensor_json() function.
	"""
	newSensorName = self.textbox_new_name.Text
	newSensorPin = self.combobox_pin.SelectedItem	
	print("Adding new sensor...")
	new_sensor_json(self, newSensorName, newSensorPin)

def new_sensor_json(self, Name, Pin):
	""" This function checks if new sensor name and/or new sensor PIN is being 
	used within new_sensor_list.json, if not, it can be written.

	Args: 	Name (str)
			Pin  (str)
	"""
	new_sensor = {}
	saved_sensors = []
	
	with open(datafallback + '\\new_sensor_list.json', 'r+')\
								 as saved_sensors_file:					
		new_sensor = json.load(saved_sensors_file)						
			
		if self.textbox_new_name.Text not in new_sensor.keys():
			if self.combobox_pin.SelectedItem not in new_sensor.values():
				new_sensor[Name] = Pin
				saved_sensors_file.seek(0)
				json.dump(new_sensor, saved_sensors_file)
				saved_sensors_file.truncate()
				saved_sensors_file.close()
				print("New sensor added.")
				update_sensor_list(self)
			else:
				print("NOT possible: Pin " + self.combobox_pin.SelectedItem\
								 + " in use")			
		else:
			print("NOT possible: Sensor " + self.textbox_new_name.Text\
								+ " already exists.")
			saved_sensors_file.close()
	

def delete_sensor(self):	
	"""This function checks if the desired sensor exists both in new_sensor_list
	and sensor_data. If it does, the function delete in both files. Also, 
	it updates the sensor list inside the UI.
	"""
	with open(datafallback + '\\new_sensor_list.json', 'r+')\
		as saved_sensors_file, open(datafallback + '\\sensors_data.json', 'r+')\
		as existing_sensors_file:
		saved_dict = json.load(saved_sensors_file)
		exist_dict = json.load(existing_sensors_file)
		print(str(saved_dict))

		if self.textbox_new_name.Text in saved_dict.keys():
			if self.textbox_new_name.Text in exist_dict.keys():
				del exist_dict[self.textbox_new_name.Text]
				del saved_dict[self.textbox_new_name.Text]
				saved_sensors_file.seek(0)
				json.dump(saved_dict, saved_sensors_file)
				saved_sensors_file.truncate()
				saved_sensors_file.close()				

				existing_sensors_file.seek(0)
				json.dump(exist_dict, existing_sensors_file)
				existing_sensors_file.truncate()
				existing_sensors_file.close()

				update_sensor_list(self)						
				print("Sensor "+ self.textbox_new_name.Text + " deleted.")
			else: 
				print("NOT possible: Sensor NOT found sensor data file.")

		else:
			print("NOT possible: Sensor NOT found in new sensors file.")
			saved_sensors_file.close()
		
	
def update_sensor_list(self):
	"""The purpose of this function is to update the sensor list inside UI.
	"""
	sensors = []
	with open(datafallback + '\\new_sensor_list.json', "r")\
					 as sensors_read_file:
	   	data = json.load(sensors_read_file)
	   	sensors_read_file.close()

	for sensor_name in data:
	    sensors.append(sensor_name)

	self.combobox_sensors.ItemsSource = sensors
	print("The sensor list has been updated.")


def sensor_reader(self):
	""" Fist this function calls refresh_sensor_reader() function and takes the
	updated dict connected_pin. Then, the function reads the data and dump it
	inside sensors_data.jason
	"""
	print("Reading sensors output... ")
	get_pin = refresh_sensor_reader()
	read_pin = {}		

	for sensor in get_pin:
		read_pin[sensor] = get_pin[sensor].read()

	# Prints the sensor data
	print(str(read_pin))

	with open(datafallback + '\\sensors_data.json', 'w')\
							 as sensors_json_file:
		json.dump(read_pin, sensors_json_file)
		sensors_json_file.close()


def export_img(self):
	""" This function export revit current view image .PNG with 'level_1' name
	to datafallback location and then updates UI background image.
	"""
	options = ImageExportOptions()
	options.ExportRange = ExportRange.CurrentView
	options.FilePath = os.path.join(datafallback, 'level_1')
	options.HLRandWFViewsFileType = ImageFileType.PNG
	options.ImageResolution = ImageResolution.DPI_300
	options.ZoomType = ZoomFitType.Zoom
	options.ShadowViewsFileType = ImageFileType.PNG

	doc.ExportImage(options)    

	self.backgroundimage.Source = forms.utils\
				.bitmap_from_file(datafallback +  '\\level_1.png')
	print("Background image has been updated.")
        

def attach_sensors(self):
	""" Here we have the option to attach specific sensor to a specifit hospital
	bed. The function checks if the hospital bed is being used. This attachment 
	is saved within assigned_list.json.
	"""	
	sensorID = {}
	sensor_array = []
	
	with open(datafallback + '\\assigned_list.json', 'r+')\
									 as assigned_json_file:

		jsonfilereader = assigned_json_file.read()

		if self.combobox_sensors.SelectedItem in jsonfilereader:
			print("NOT possible: The selected sensor is being used.")

		else:
			sensorID[self.combobox_sensors.SelectedItem] = self\
							.combobox_beds.SelectedItem
			assigned_json_file\
			.write((str(sensorID).replace("\'", "\"")) + "\n")
			print("Sensor attached.")

		assigned_json_file.close()


def detach_sensor(self):
	""" Opens assigned_list.json and checks if desired sensor is there. Then it 
	locates the sensor position inside the dict and delete it from 
	assigned_list.json file.
	"""
	# Array where all assigned sensors go
	jsonObjs = []
	# Index array of future deleted sensor.
	del_jsonObjs = []
	
	open_assigned_list = open(datafallback + '\\assigned_list.json', mode="r")

	try:
		for line in open_assigned_list:			
			jsonObjs.append(json.loads(line))

		if str(self.combobox_sensors.SelectedItem) in str(jsonObjs):		
			for item in jsonObjs:				
				for key in item:
					# Search for sensor index 									
					if str(self.combobox_sensors.SelectedItem) == str(key):
						del_jsonObjs.append(jsonObjs.index(item))					

			with open(datafallback + '\\assigned_list.json', 'w+')\
												 as assigned_json_file:
				# Deletion
				del jsonObjs[del_jsonObjs[0]]
				# Rewrite every line inside assigned_json_file
				for new_jsonObj in jsonObjs:							
					assigned_json_file.write((str(new_jsonObj)\
												.replace("\'", "\"")) + "\n")
				print("Sensor detached.")
				assigned_json_file.close()
		else:
			print("NOT possible: Sensor not found.")
	finally:
		open_assigned_list.close()
		

def beds_occupied(self):
	""" This function verify if each hospital bed in the model is occupied or
	not. First it collects all beds and store it in white beds array. Then it 
	open both assigned_list.json and sensors_data.json and append both data 
	into assigned_list and sensors_list arrays.

	If the bed is occupied the sensor will throw FALSE values, the function will
	check for FALSE values inside sensors_list arrays. If it is FALSE it will be
	appended to false_values array.

	A revit transaction starts and for each FALSE values it search the sensor
	inside assigned_list and override its color to red. Then it delete this 
	sensor from white_beds array. (It contained ALL sensors)

	Finally it override all white_beds array to white color.

	"""
	print("Verifying beds occupancy...")
	assigned_list = []
	sensors_list = []
	false_values = []	
	white_beds = []

	beds_collector = FilteredElementCollector(doc)\
					.OfCategory(BuiltInCategory.OST_SpecialityEquipment)\
					.WhereElementIsNotElementType()
	for bed in beds_collector:
		white_beds.append(bed.Id.IntegerValue)    

	with open(datafallback + '\\assigned_list.json', 'r') as open_assigned_list:
		texto = open_assigned_list.readlines()		
		for line in texto:			
			assigned_list.append(json.loads(line.replace("\n", "")))
		open_assigned_list.close()

	with open(datafallback + '\\sensors_data.json','r') as open_sensor_data:
		sensors_list.append(json.load(open_sensor_data))
		open_sensor_data.close()
	
			
	for key in sensors_list[0]:
		if sensors_list[0][key] == False:
			false_values.append(key)

	t = Transaction(doc, 'Beds Occupied')		
	t.Start()
	# Override the color to red	
	for false_value in false_values:		
		for dic in assigned_list:			
			if str(false_value) == dic.keys()[0]:				
				elementID = assigned_list[assigned_list.index(dic)]\
												[str(dic.keys()[0])]
				# Remove the red beds
				white_beds.remove(elementID)				
				
				color = Color(255,50,50)
				ogs = OverrideGraphicSettings()\
								.SetSurfaceForegroundPatternColor(color)
							
				doc.ActiveView.SetElementOverrides(ElementId(elementID), ogs)			
				
			else:
				continue

	false_values = []	
	# Overrides color to white
	for white_bed in white_beds:											
		elementID_true = white_bed		
		
		color_black = Color(255,255,255)
		ogs_black = OverrideGraphicSettings()\
						.SetSurfaceForegroundPatternColor(color_black)
				
		doc.ActiveView.SetElementOverrides(ElementId(elementID_true), ogs_black)		
		
	t.Commit()
	export_img(self)
	print("Occupied beds verification done and colors applied.")

initial_loading()
refresh_sensor_reader()
MyWindow().ShowDialog()








